WARNING: unknown option '-c'

ARGUMENT '303JSH' __ignored__


R version 2.12.0 (2010-10-15)
Copyright (C) 2010 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: i686-pc-linux-gnu (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("bb.r")
> source("syn.r")
> source("gen.r")
> require(survival)
> require(maptools)
> require(sp)
> 
> ################################################
> #Handle Options
> i <- 0
> cluster <- ""
> bb.only <- FALSE
> syn.only <- FALSE
> parallel <- FALSE
> do.to.js <- FALSE #date offset to julian seconds
> nodes <- 1
> options <- commandArgs()
> for(option in options) {
+ 	i <- i + 1
+ 	print(options[i])
+     	if(option == "-c"){
+        		cluster <- options[i + 1]
+      	}
+ 	if(option == "--bb-only") {
+ 		bb.only <- TRUE
+ 	}
+ 	if(option == "--syn-only") {
+ 		syn.only <- TRUE
+ 	}
+ 	if(option == "--do-to-js") {
+ 		do.to.js <- TRUE
+ 	}
+ 	if(option == "-p") {
+ 		parallel <- TRUE
+ 		nodes <- options[i + 1]
+ 	}
+ }
[1] "/mnt/home/module/apps/i386/devel/lang/R/2.12.0/lib/R/bin/exec/R"
[1] "--no-save"
[1] "-c"
[1] "303JSH"
> 
> ###############################################
> #Parallel Setup
> if(parallel == TRUE) {
+ 	require(Rmpi)
+ 	require(snow)
+ 	c1 <- makeCluster(nodes, type="MPI")
+ }
> source("step.r")
> 
> #################################################
> #Set working directories
> workdir = paste(getwd(),"/data/",cluster,sep="")
> basedir = getwd()
> print(paste("Using",workdir,"as workdir"))
[1] "Using /mnt/lfs/cblair/firefly_home/cluster_tests/ncmgrp/SYN2/data/303JSH as workdir"
> setwd(workdir)
> 
> #################################################
> #Profiling for performance
> profile.fname = paste(workdir,"/profile.dat", sep="")
> Rprof(profile.fname)
> 
> #################################################
> #Setup data
> alfname = paste(workdir,"/",cluster,"_all_locations.txt",sep="")
> #al = all locations
> al = read.table(alfname, sep='\t',header=TRUE, as.is=TRUE)
> #ma setup
> ma.flist = unique(al$ExtentFile)
> 
> #ma.flist = list.files(workdir,pattern=paste(cluster,"_master_avail*",sep=""))
> ma.list <- lapply(1:length(ma.flist), function(i) {
+ 	masterfname = paste(workdir,"/",ma.flist[i],sep="")
+ 	retval <- read.table(masterfname, sep='\t',header=TRUE, as.is=TRUE)
+ 	retval$ExtentFile = ma.flist[i]
+ 	return(retval)
+ } )
> 
> #################################################
> #Process for each ma in the ma list
>  
> #make one big ma for use in normalization
> ma.combined <- ma.list[[1]]
> if(length(ma.list) > 1) {
+ 	for(i in 2:length(ma.list)) {ma.combined <- rbind(ma.combined, ma.list[[i]])}
+ }
> 
> 
> #al normalize
> for(coln in names(al)) {
+ 	if((coln != "x") && (coln != "y") && (coln != "time") && (coln != "sd") && (coln != "ExtentFile")) {
+ 		#al[,i] <- (al[,i] - min(ma[,i-2])) /  (max(ma[,i-2]) - min(ma[,i-2]))
+ 		if(coln %in% names(ma.combined)) {
+ 			print(paste("Normalizing location data column",coln))
+ 			al[,coln] <- (al[,coln] - min(ma.combined[,coln])) /  (max(ma.combined[,coln]) - min(ma.combined[,coln]))
+ 		} else {
+ 			print(paste("Warning: column",coln,"in location data, but not in habitat data."))
+ 		}
+ 	}
+ }
[1] "Normalizing location data column d2et"
[1] "Normalizing location data column slope"
[1] "Normalizing location data column elevm"
[1] "Normalizing location data column forest"
[1] "Normalizing location data column shrub"
[1] "Normalizing location data column talus"
> #end al normalize
> #to add - tell them mins and max's and ask them if they want to input their own
> #ma normalize
> for(i in 1:length(ma.list)) {
+ 	for(coln in names(ma.combined)) {
+ 		if((coln != "x") && (coln != "y") && (coln != "time") && (coln != "sd") && (coln != "ExtentFile")) {
+                		#ma[,i] <-  (ma[,i] - min(ma[,i])) /  (max(ma[,i]) - min(ma[,i])) 
+ 			print(paste("Normalizing habitat data column",coln))
+ 			ma.list[[i]][,coln] <-  (ma.list[[i]][,coln] - min(ma.combined[,coln])) /  (max(ma.combined[,coln]) - min(ma.combined[,coln])) 
+ 		}
+ 	}
+ }
[1] "Normalizing habitat data column d2et"
[1] "Normalizing habitat data column slope"
[1] "Normalizing habitat data column elevm"
[1] "Normalizing habitat data column forest"
[1] "Normalizing habitat data column shrub"
[1] "Normalizing habitat data column talus"
> #end ma normalize
> 
> #record what mins and maxes we used for normlization
> #x <- data.frame(min=(min(ma.combined)),max=(max(ma.combined)))
> #write.table(x,file="norm_data.r")
> 
> #import habitat (ma) models
> source("models.r")
> #add required values to models
> #ModelsList <- lapply(1:length(ModelsList), function(z) {
> #		return(c("x","y",ModelsList[z],recursive=TRUE))
> #	} )
> 
> #build cellgrid
> # calculate auxillary variables
> bb.var <- get.bb.var(al) #bb variance
> cellgrid <- list()
> print("Starting cellgrid construction...")
[1] "Starting cellgrid construction..."
> starttime <- proc.time()[3]
> if(parallel) {	
+ 	clusterExport(c1, "al")
+ 	clusterExport(c1, "ma.list")
+ 	#cellgrid <- parLapply(c1, 1:length(al$x), get.cellgrid)
+ 	print("Starting par cellgrid construction")
+ 	cellgrid <- parLapply(c1, 1:length(al$x), get.cellgrid.with.mas)
+ } else {
+ 	#cellgrid <- lapply(1:length(al$x), get.cellgrid)
+ 	cellgrid <- lapply(1:length(al$x), get.cellgrid.with.mas)
+ }
[1] "Middle location 64  is outside of extent"
> cellgrid <- cellgrid[!is.na(cellgrid)]
> endtime <- proc.time()[3]
> print(paste("Cellgrid construction time was",endtime - starttime))
[1] "Cellgrid construction time was 13.587"
> 
> 
> ma.gridsize <- get.ma.gridsize(ma.combined) 
> 
> 
> #################################################
> #Process options
> if(do.to.js == TRUE) {
+ 	al$Julian <- al$time * 24 * 60 * 60
+ 	al = al[order(al$Julian),]
+ }
> 
> #else, we are doing bb and syn by triplicates
> synbb.outfile = "step"
> 
>         
> #################################################3
> #Start for processing
> 
> #apply operations foreach element in the cellgrid
> foreach.cellgrid <- function(i) {
+ 	if(!is.na(cellgrid[i][[1]][[2]])) {
+ 		synbb.outfile <<- paste("trip-",i,sep="")
+ 		#print(paste("Running bb for cellgrid",i,"of",length(cellgrid)))
+ 		#cellgrid[i][[1]][[3]]$Julian <- cellgrid[3][[1]][[3]]$time * 24 * 60
+ 		#bb(cellgrid[i][[1]][[3]], bb.var)
+ 	}
+ 	#else {
+ 		
+ 	#}
+ }
> 
> #if(parallel) {	
> #	clusterExport(c1, "cellgrid")
> #	clusterExport(c1, "bb")
> #	parLapply(c1, 1:length(cellgrid), foreach.cellgrid)
> #} else {
> 	lapply(1:length(cellgrid), foreach.cellgrid)
[[1]]
[1] "trip-1"

[[2]]
[1] "trip-2"

[[3]]
[1] "trip-3"

[[4]]
[1] "trip-4"

[[5]]
[1] "trip-5"

[[6]]
[1] "trip-6"

[[7]]
[1] "trip-7"

[[8]]
[1] "trip-8"

[[9]]
[1] "trip-9"

[[10]]
[1] "trip-10"

[[11]]
[1] "trip-11"

[[12]]
[1] "trip-12"

[[13]]
[1] "trip-13"

[[14]]
[1] "trip-14"

[[15]]
[1] "trip-15"

[[16]]
[1] "trip-16"

[[17]]
[1] "trip-17"

[[18]]
[1] "trip-18"

[[19]]
[1] "trip-19"

[[20]]
[1] "trip-20"

[[21]]
[1] "trip-21"

[[22]]
[1] "trip-22"

[[23]]
[1] "trip-23"

[[24]]
[1] "trip-24"

[[25]]
[1] "trip-25"

[[26]]
[1] "trip-26"

[[27]]
[1] "trip-27"

[[28]]
[1] "trip-28"

[[29]]
[1] "trip-29"

[[30]]
[1] "trip-30"

[[31]]
[1] "trip-31"

[[32]]
[1] "trip-32"

[[33]]
[1] "trip-33"

[[34]]
[1] "trip-34"

[[35]]
[1] "trip-35"

[[36]]
[1] "trip-36"

[[37]]
[1] "trip-37"

[[38]]
[1] "trip-38"

[[39]]
[1] "trip-39"

[[40]]
[1] "trip-40"

[[41]]
[1] "trip-41"

[[42]]
[1] "trip-42"

[[43]]
[1] "trip-43"

[[44]]
[1] "trip-44"

[[45]]
[1] "trip-45"

[[46]]
[1] "trip-46"

[[47]]
[1] "trip-47"

[[48]]
[1] "trip-48"

[[49]]
[1] "trip-49"

> #}
> 
> 
> print("Processing syn using cellgrids...")
[1] "Processing syn using cellgrids..."
> synbb.outfile = "syn"
> syn(al)
[1] "TS51: start.val"
[1] 5.190928
[1] "TS272"
[1] 5.190928
[1] "loglikelihood"
[1] -656.7149
[1] "loglikelihood"
[1] -656.7342
[1] "loglikelihood"
[1] -656.6957
[1] "loglikelihood"
[1] -792.8289
[1] "loglikelihood"
[1] -792.4077
[1] "loglikelihood"
[1] -793.251
[1] "loglikelihood"
[1] -655.4678
[1] "loglikelihood"
[1] -655.4695
[1] "loglikelihood"
[1] -655.4663
[1] "loglikelihood"
[1] -655.4606
[1] "loglikelihood"
[1] -655.4604
